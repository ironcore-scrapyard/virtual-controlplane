{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Virtual Controlplane \u00b6 The project contains a collection of helm charts to deploy a virtual/nodeless Kubernetes API server . Background \u00b6 Why do we need such a thing as a nodeless Kubernetes cluster? When developing a custom controlplane by extending Kubernetes and using the Operator Pattern we typically might not be interested in objects like Pods , Deployments and others. The goal instead is to introduce new CustomResourceDefinitions on which our controllers will operate by leveraging the concepts the Kubernetes API machinery is offering us. In order to do it, we will need certain things such as: etcd server (ideally with a backup and restore sidecar 1 ) kube-api-server and kube-controller-manager Since this Kubernetes API server setup does not have any nodes, we don't need to deploy the kube-scheduler as we won't be deploying any Pods . Those components can be easily deployed on an existing Kubernetes cluster 2 . The figure above illustrates the core components which are deployed on a vanilla Kubernetes runtime cluster. Your custom controllers can now also be deployed on the same (or different) runtime cluster as illustrated in the image above. Advantages \u00b6 The main advantage of this approach is, that controllers and the content inside of virtual Kubernetes API server are no longer physically bound to the underlying runtime cluster as your CRDs are not mixed with content of the runtime clusters API server. Since the virtual controlplane in our scenario is just another workload running in a Kubernetes cluster, it can be moved and restored to a different cluster in case disaster strikes and the runtime cluster becomes unavailable. Another advantage is, that the performance of the virtual Kubernetes API server becomes a lot more predictable since nobody besides your controllers 3 are working against it. In our setup we are reusing the great work from the Gardener project. \u21a9 This can also be done on a classical virtual machine based setup. \u21a9 And maybe the kube-controller-manager . \u21a9","title":"Home"},{"location":"#virtual-controlplane","text":"The project contains a collection of helm charts to deploy a virtual/nodeless Kubernetes API server .","title":"Virtual Controlplane"},{"location":"#background","text":"Why do we need such a thing as a nodeless Kubernetes cluster? When developing a custom controlplane by extending Kubernetes and using the Operator Pattern we typically might not be interested in objects like Pods , Deployments and others. The goal instead is to introduce new CustomResourceDefinitions on which our controllers will operate by leveraging the concepts the Kubernetes API machinery is offering us. In order to do it, we will need certain things such as: etcd server (ideally with a backup and restore sidecar 1 ) kube-api-server and kube-controller-manager Since this Kubernetes API server setup does not have any nodes, we don't need to deploy the kube-scheduler as we won't be deploying any Pods . Those components can be easily deployed on an existing Kubernetes cluster 2 . The figure above illustrates the core components which are deployed on a vanilla Kubernetes runtime cluster. Your custom controllers can now also be deployed on the same (or different) runtime cluster as illustrated in the image above.","title":"Background"},{"location":"#advantages","text":"The main advantage of this approach is, that controllers and the content inside of virtual Kubernetes API server are no longer physically bound to the underlying runtime cluster as your CRDs are not mixed with content of the runtime clusters API server. Since the virtual controlplane in our scenario is just another workload running in a Kubernetes cluster, it can be moved and restored to a different cluster in case disaster strikes and the runtime cluster becomes unavailable. Another advantage is, that the performance of the virtual Kubernetes API server becomes a lot more predictable since nobody besides your controllers 3 are working against it. In our setup we are reusing the great work from the Gardener project. \u21a9 This can also be done on a classical virtual machine based setup. \u21a9 And maybe the kube-controller-manager . \u21a9","title":"Advantages"},{"location":"development/contribution/","text":"","title":"Contribution Guide"},{"location":"development/documentation/","text":"","title":"Documentation"},{"location":"development/setup/","text":"","title":"Setup"},{"location":"development/testing/","text":"","title":"Testing"},{"location":"usage/cert-manager/","text":"CertManager \u00b6 We are using the cert-manager to generate and update TLS certificates. Please refer to the cert-manager installation documentation for details. Installation \u00b6 Add the cert-manager helm repository: helm repo add jetstack https://charts.jetstack.io helm repo update The cert-manager can be installed via: helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.5.3 \\ --set installCRDs = true \\ --set extraArgs ={ \"--enable-certificate-owner-ref=true\" } Upgrade \u00b6 helm -n cert-manager upgrade cert-manager \\ jetstack/cert-manager -f VALUES_DIR/cert-manager-values.yaml Remove \u00b6 To uninstall the cert-manager from your cluster run: helm -n cert-manager delete cert-manager","title":"Cert Manager"},{"location":"usage/cert-manager/#certmanager","text":"We are using the cert-manager to generate and update TLS certificates. Please refer to the cert-manager installation documentation for details.","title":"CertManager"},{"location":"usage/cert-manager/#installation","text":"Add the cert-manager helm repository: helm repo add jetstack https://charts.jetstack.io helm repo update The cert-manager can be installed via: helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.5.3 \\ --set installCRDs = true \\ --set extraArgs ={ \"--enable-certificate-owner-ref=true\" }","title":"Installation"},{"location":"usage/cert-manager/#upgrade","text":"helm -n cert-manager upgrade cert-manager \\ jetstack/cert-manager -f VALUES_DIR/cert-manager-values.yaml","title":"Upgrade"},{"location":"usage/cert-manager/#remove","text":"To uninstall the cert-manager from your cluster run: helm -n cert-manager delete cert-manager","title":"Remove"},{"location":"usage/druid/","text":"Etcd Druid \u00b6 The etcd-druid is an operator which manages etcd deployments inside a Kubernetes cluster. Installation \u00b6 etcd-druid can be installed via helm install into your Kubernetes cluster. Please make sure you have configured the helm repo as described here . helm -n onmetal install druid vc/etcd-druid If you want to overwrite the default values.yaml you can do so by providing a custom configuration. helm -n onmetal install druid vc/etcd-druid -f VALUES_DIR/druid-values.yaml Note Please refer to the chart readme for detailed information on the value parameters. Upgrade \u00b6 To upgrade your etcd-druid deployment run: helm -n onmetal upgrade druid vc/etcd-druid -f VALUES_DIR/druid-values.yaml Remove \u00b6 To remove the installation run: helm -n onmetal delete druid","title":"Druid"},{"location":"usage/druid/#etcd-druid","text":"The etcd-druid is an operator which manages etcd deployments inside a Kubernetes cluster.","title":"Etcd Druid"},{"location":"usage/druid/#installation","text":"etcd-druid can be installed via helm install into your Kubernetes cluster. Please make sure you have configured the helm repo as described here . helm -n onmetal install druid vc/etcd-druid If you want to overwrite the default values.yaml you can do so by providing a custom configuration. helm -n onmetal install druid vc/etcd-druid -f VALUES_DIR/druid-values.yaml Note Please refer to the chart readme for detailed information on the value parameters.","title":"Installation"},{"location":"usage/druid/#upgrade","text":"To upgrade your etcd-druid deployment run: helm -n onmetal upgrade druid vc/etcd-druid -f VALUES_DIR/druid-values.yaml","title":"Upgrade"},{"location":"usage/druid/#remove","text":"To remove the installation run: helm -n onmetal delete druid","title":"Remove"},{"location":"usage/etcd/","text":"Etcd \u00b6 etcd is the main backend storage of the Kubernetes API server. We will be using our etcd-druid operator to deploy a production ready etcd cluster. Installation \u00b6 etcd can be installed via helm install into your Kubernetes cluster. Please make sure you have configured the helm repo as described here . helm -n onmetal install etcd vc/etcd If you want to overwrite the default values.yaml you can do so by providing a custom configuration. helm -n onmetal install etcd vc/etcd -f VALUES_DIR/etcd-values.yaml Note Please refer to the chart README for detailed information on the value parameters. Upgrade \u00b6 To upgrade your etcd deployment run: helm -n onmetal upgrade etcd vc/etcd -f VALUES_DIR/etcd-values.yaml Remove \u00b6 To remove the installation run: helm -n onmetal delete etcd","title":"Etcd"},{"location":"usage/etcd/#etcd","text":"etcd is the main backend storage of the Kubernetes API server. We will be using our etcd-druid operator to deploy a production ready etcd cluster.","title":"Etcd"},{"location":"usage/etcd/#installation","text":"etcd can be installed via helm install into your Kubernetes cluster. Please make sure you have configured the helm repo as described here . helm -n onmetal install etcd vc/etcd If you want to overwrite the default values.yaml you can do so by providing a custom configuration. helm -n onmetal install etcd vc/etcd -f VALUES_DIR/etcd-values.yaml Note Please refer to the chart README for detailed information on the value parameters.","title":"Installation"},{"location":"usage/etcd/#upgrade","text":"To upgrade your etcd deployment run: helm -n onmetal upgrade etcd vc/etcd -f VALUES_DIR/etcd-values.yaml","title":"Upgrade"},{"location":"usage/etcd/#remove","text":"To remove the installation run: helm -n onmetal delete etcd","title":"Remove"},{"location":"usage/helm/","text":"Helm Repository \u00b6 The virtual-controlplane project comes with it's own Helm repository containing all Helm charts necessary to setup a virtual Kubernetes API server. It can be added to your Helm environment via: helm repo add vc https://onmetal.github.io/virtual-controlplane/ To update the Helm repository: helm repo update You should now be able to see the content of the helm repository via: helm search repo vc An example output would look like this: NAME CHART VERSION APP VERSION DESCRIPTION vc/etcd-druid 0 .1.0 0 .6.0 Helm chart for etcd-druid.","title":"Helm Repository"},{"location":"usage/helm/#helm-repository","text":"The virtual-controlplane project comes with it's own Helm repository containing all Helm charts necessary to setup a virtual Kubernetes API server. It can be added to your Helm environment via: helm repo add vc https://onmetal.github.io/virtual-controlplane/ To update the Helm repository: helm repo update You should now be able to see the content of the helm repository via: helm search repo vc An example output would look like this: NAME CHART VERSION APP VERSION DESCRIPTION vc/etcd-druid 0 .1.0 0 .6.0 Helm chart for etcd-druid.","title":"Helm Repository"},{"location":"usage/overview/","text":"Overview \u00b6","title":"Overview"},{"location":"usage/overview/#overview","text":"","title":"Overview"}]}